mkdir 创建新的文件夹
cd    进入一个文件夹
ls    显示文件夹下的内容（可视内容）
ls -al 显示文件夹下的所有内容(可视的内容和隐藏的内容)
1. 预解释：
   概念：在当前作用域下，在JS代码执行之前，浏览器会对带var和带function进行提前声明或者定义；
   声明：告诉浏览器有这么一个变量，但是没有赋值，没赋值拿到的undefined;
   定义：对已经声明过的这个变量进行赋值
   关于变量和函数预解释阶段的不同
   带var :只声明不定义
   带function:声明+定义；
2. 函数包含：定义+调用
       定义3步骤：
           1.开辟一个空间地址
           2.把函数体中所有JS代码做为字符串存在这个空间中
           3.把空间地址赋值给函数名
       函数调用3步骤：
           1.对形参赋值；
           2.预解释 var n;
           3.JS代码从上到下的执行
3. 作用域链：当函数执行的时候，形成一个私有作用域A,查看作用域中的这个变量是否为私有变量：
    1）如果是私有变量：这个函数中的所有此变量，跟外面没有任何关系；
    2）如果不是私有变量：
        1.如果是获取；往上级作用域进行查找，如果找到，弹出，找不到继续往上级作用域进行查找。。。。最终一直找到window，如果还没有，报错
        2.如果是设置；往上级作用域进行查找，如果找到，重新赋值；找不到继续往上级作用域进行查找。。。。最终一直找到window，如果还没有，他就是window上的全局属性；
4. 关于作用域
   全局作用域：当浏览器加载html页面的时候，会形成一个供js代码执行的环境，在这个全局作用域下，所有的全局变量都是window上的全局属性
5. 私有变量有且只有两种
   1. 带var的
   2. 形参
6. 预解释的无节操
   1. 自执行函数不需要预解释，当代码执行到它的时候，声明+定义+调用同步完成
   2. 已经声明过的变量，不需要重新声明，只需要重新赋值
   3. 带var的只声明不定义
   4. if条件语句，不论条件是否成立，都会进行预解释
   5.return返回值不进行预解释，return下面的语句虽然不执行，但是会进行预解释
7. 闭包的作用
   1. 防止变量名冲突
   2. 在闭包中对全局变量重新赋值，并且不影响全局变量
   3. 可以通过window.xx改变全局变量；
   4. 闭包可以用来封装；可以通过window.xxx=函数名；
关于this
   1. 当触发一个元素身上的事件，执行对应的函数的时候，函数中的this，指向当前这个元素
   2. 当函数执行的时候"."前面是谁，this就是谁
   3. 自执行函数中的this，永远都是window
8. 面向对象的特点
   1.封装 继承 多态【重载和重写】
   在js中不存在严格意义上的重载，但是js中有类似重载的功能，同一个函数传不同的参数，实现不同的功能
   重写：子类可以重写父类的属性和方法
9. 1) 每一个函数数据类型（类，普通函数）上都天生自带一个属性，叫做prototype（原型），它是一个对象
   2) prototype这个原型上，天生自带一个属性，叫做constructor，指向当前所属的类 constructor：类
   3) 每个对象上(实例，普通对象，prototype)上，都天生自带一个属性，叫做__proto__它指向当前实例所属类的原型
   Object.prototype：都放的是公有的属性和方法
   hasOwnProperty：判断attr这个属性是否是这个对象上的私有属性
   isProtoTypeOf: obj1是否在obj2的原型上
   propertyIsEnumerable：是否可枚举的属性