1.let const
 let 作用域块 不存在变量提升 变量不可以在声明之前使用
 不允许在相同作用域重复声明 会报错
 不能在函数内部重新声明参数
 es6允许块级作用域中声明函数块级作用域外不可引用
 const常量 一旦声明值就不可以改变 一旦声明就必须赋值初始化 只声明不赋值会报错  不存在变量提升

 ES6中有6种声明变量的方法

let const class命令声明的全局变量不属于顶层对象的属性
不管在严格模式还是普通模式，new Function('return this')()总是会返回全局对象
2.解构赋值
允许指定默认值 let [x,y = 'b'] = ['a'];//x = a,y = b;
ES6内部使用严格相等运算符（===）判断一个位置是否有值，如果一个数组成员不严格等于undefined,默认值不会生效
```
    let [x = 1] = [undefined];//x = 1;

    let [x = 1] = [null];// x = null;
```
3.字符串的扩展
includes() startsWith() endsWith()
repeat() 返回一个新字符串表示将原字符串重复n次
padStart() padEnd()
模板字符串 `hello${x}`
模板字符串的空格和换行都是被保留的 可以用` `.trim()去掉
4.数组新增方法
 Array.from()将两类对象转换为真正的数组
 1.类数组
 2.可遍历的对象
 (...)也可以将某些数据结构转换为数组
 Array.of()把一组数转换为数组
...[1,2,3]=>1,2,3
4. 箭头函数
 f =>v function f(){return v;}
 如果箭头函数直接返回一个对象，必须在对象外面加上括号
 
 注意点：
 1) 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象
 2) 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
 3) 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。
 4) 不可以使用yield命令，因此箭头函数不能用作Generator函数。
 